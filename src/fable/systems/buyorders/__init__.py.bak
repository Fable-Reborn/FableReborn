"""
The IdleRPG Discord Bot
Copyright (C) 2024 Lunar (discord itslunar.)

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU Affero General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Affero General Public License for more details.

You should have received a copy of the GNU Affero General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.
"""
import asyncio
import datetime
import random
import uuid
from enum import Enum
from typing import Dict, List, Optional, Union, Tuple
from contextlib import suppress

import discord
from discord.ext import commands, tasks
from discord.http import handle_message_parameters

from fable.core.converters import (
    CrateRarity,
    IntFromTo,
    IntGreaterThan,
    MemberWithCharacter,
)
from fable.utils.checks import has_char
from fable.utils.i18n import _, locale_doc


class OrderType(Enum):
    WEAPON = "weapon"
    CRATE = "crate"


class BuyOrders(commands.Cog):
    def __init__(self, bot):
        self.bot = bot
        # Get emotes from crates cog for display
        self.crate_emotes = None
        if hasattr(self.bot.cogs.get("Crates", None), "emotes"):
            self.crate_emotes = self.bot.cogs["Crates"].emotes
        self._init_db.start()

    @tasks.loop(count=1)
    async def _init_db(self):
        """Create necessary database tables if they don't exist."""
        async with self.bot.pool.acquire() as conn:
            # Table for weapon buy orders
            await conn.execute("""
                CREATE TABLE IF NOT EXISTS weapon_buy_orders (
                    id SERIAL PRIMARY KEY,
                    user_id BIGINT NOT NULL,
                    weapon_type TEXT NOT NULL,
                    min_stat INTEGER NOT NULL,
                    max_stat INTEGER NOT NULL,
                    price BIGINT NOT NULL,
                    quantity INTEGER NOT NULL,
                    quantity_filled INTEGER NOT NULL DEFAULT 0,
                    created_at TIMESTAMP DEFAULT NOW(),
                    active BOOLEAN DEFAULT TRUE
                );
            """)
            
            # Table for crate buy orders
            await conn.execute("""
                CREATE TABLE IF NOT EXISTS crate_buy_orders (
                    id SERIAL PRIMARY KEY,
                    user_id BIGINT NOT NULL,
                    crate_type TEXT NOT NULL,
                    price_each BIGINT NOT NULL,
                    quantity INTEGER NOT NULL,
                    quantity_filled INTEGER NOT NULL DEFAULT 0,
                    created_at TIMESTAMP DEFAULT NOW(),
                    active BOOLEAN DEFAULT TRUE
                );
            """)
            
            # Table for buy order fulfillment history
            await conn.execute("""
                CREATE TABLE IF NOT EXISTS buy_order_fulfillments (
                    id SERIAL PRIMARY KEY,
                    order_id INTEGER NOT NULL,
                    order_type TEXT NOT NULL,
                    seller_id BIGINT NOT NULL,
                    buyer_id BIGINT NOT NULL,
                    item_id INTEGER,
                    crate_type TEXT,
                    crate_quantity INTEGER,
                    price BIGINT NOT NULL,
                    fulfilled_at TIMESTAMP DEFAULT NOW()
                );
            """)

    @_init_db.before_loop
    async def before_init_db(self):
        await self.bot.wait_until_ready()
    
    async def get_crate_emoji(self, crate_type: str) -> str:
        """Get the emoji for a crate type."""
        if self.crate_emotes is None and hasattr(self.bot.cogs.get("Crates", None), "emotes"):
            self.crate_emotes = self.bot.cogs["Crates"].emotes
            
        if self.crate_emotes and hasattr(self.crate_emotes, crate_type.lower()):
            return getattr(self.crate_emotes, crate_type.lower())
        return "ðŸ“¦"
    
    @has_char()
    @commands.group(aliases=["bo"], invoke_without_command=True, brief=_("Buy order commands"))
    @locale_doc
    async def buyorder(self, ctx):
        _("""Group of commands for the buy order system. Use help on the subcommands for more info.
        
        Buy orders allow you to place standing orders for items or crates at specified prices.
        Other players can fulfill these orders by selling their items to you.""")
        await ctx.send(_(
            "Buy Order Commands:\n"
            f"`{ctx.clean_prefix}buyorder create` - Create a new buy order\n"
            f"`{ctx.clean_prefix}buyorder view` - View your active buy orders\n"
            f"`{ctx.clean_prefix}buyorder cancel` - Cancel one of your buy orders\n"
            f"`{ctx.clean_prefix}buyorder list` - List all active buy orders\n"
            f"`{ctx.clean_prefix}buyorder history` - View your buy order history\n"
            f"`{ctx.clean_prefix}buyorder fulfill` - Fulfill a buy order\n"
            f"`{ctx.clean_prefix}buyorder setup` - Initialize the database tables (admin only)"
        ))

    @has_char()
    @commands.is_owner()
    @buyorder.command(name="setup", brief=_("Setup the buy order database tables"))
    @locale_doc
    async def buyorder_setup(self, ctx):
        _("""Initialize the database tables for the buy order system. Admin only command.""")
        async with self.bot.pool.acquire() as conn:
            # Table for weapon buy orders
            await conn.execute("""
                CREATE TABLE IF NOT EXISTS weapon_buy_orders (
                    id SERIAL PRIMARY KEY,
                    user_id BIGINT NOT NULL,
                    weapon_type TEXT NOT NULL,
                    min_stat INTEGER NOT NULL,
                    max_stat INTEGER NOT NULL,
                    price BIGINT NOT NULL,
                    quantity INTEGER NOT NULL,
                    quantity_filled INTEGER NOT NULL DEFAULT 0,
                    created_at TIMESTAMP DEFAULT NOW(),
                    active BOOLEAN DEFAULT TRUE
                );
            """)
            
            # Table for crate buy orders
            await conn.execute("""
                CREATE TABLE IF NOT EXISTS crate_buy_orders (
                    id SERIAL PRIMARY KEY,
                    user_id BIGINT NOT NULL,
                    crate_type TEXT NOT NULL,
                    price_each BIGINT NOT NULL,
                    quantity INTEGER NOT NULL,
                    quantity_filled INTEGER NOT NULL DEFAULT 0,
                    created_at TIMESTAMP DEFAULT NOW(),
                    active BOOLEAN DEFAULT TRUE
                );
            """)
            
            # Table for buy order fulfillment history
            await conn.execute("""
                CREATE TABLE IF NOT EXISTS buy_order_fulfillments (
                    id SERIAL PRIMARY KEY,
                    order_id INTEGER NOT NULL,
                    order_type TEXT NOT NULL,
                    seller_id BIGINT NOT NULL,
                    buyer_id BIGINT NOT NULL,
                    item_id INTEGER,
                    crate_type TEXT,
                    crate_quantity INTEGER,
                    price BIGINT NOT NULL,
                    fulfilled_at TIMESTAMP DEFAULT NOW()
                );
            """)
        await ctx.send(_("Buy order database tables have been created successfully."))

    @has_char()
    @buyorder.command(name="create", brief=_("Create a new buy order"))
    @locale_doc
    async def buyorder_create(self, ctx):
        _("""Create a new buy order for weapons or crates.
        
        This command will guide you through the process of creating a buy order step by step.
        You will be asked what type of item you want to buy (weapon or crate), the specifications,
        quantity, and price you're willing to pay.
        
        The total cost will be withdrawn from your account immediately when you create the order.
        If the order is canceled or expires, any unfulfilled portion will be refunded.""")
        
        # Ask for order type
        await ctx.send(_(
            "What type of buy order would you like to create?\n"
            "1. Weapon\n"
            "2. Crate"
        ))
        
        def check(m):
            return m.author == ctx.author and m.channel == ctx.channel and m.content in ["1", "2", "weapon", "crate"]
        
        try:
            msg = await self.bot.wait_for("message", check=check, timeout=30)
        except asyncio.TimeoutError:
            return await ctx.send(_("Buy order creation timed out."))
        
        order_type = None
        if msg.content in ["1", "weapon"]:
            order_type = OrderType.WEAPON
        else:
            order_type = OrderType.CRATE
        
        # Handle weapon order
        if order_type == OrderType.WEAPON:
            # Ask for weapon type
            weapon_types = [
                "bow", "mace", "scythe",  # Max 200
                "shield", "wand", "sword", "dagger", "knife", "hammer"  # Max 100
            ]
            
            weapon_str = ", ".join(f"`{w}`" for w in weapon_types)
            await ctx.send(_("What type of weapon are you looking for? Choose from: {types}").format(types=weapon_str))
            
            def weapon_check(m):
                return m.author == ctx.author and m.channel == ctx.channel and m.content.lower() in weapon_types
            
            try:
                weapon_msg = await self.bot.wait_for("message", check=weapon_check, timeout=30)
            except asyncio.TimeoutError:
                return await ctx.send(_("Buy order creation timed out."))
            
            weapon_type = weapon_msg.content.lower()
            
            # Determine max stat based on weapon type
            max_possible_stat = 200 if weapon_type in ["bow", "mace", "scythe"] else 100
            
            # Ask for minimum stat
            await ctx.send(_("What is the minimum stat you want for this weapon? (1-{max_stat})").format(max_stat=max_possible_stat))
            
            def min_stat_check(m):
                if not m.author == ctx.author or not m.channel == ctx.channel:
                    return False
                try:
                    stat = int(m.content)
                    return 1 <= stat <= max_possible_stat
                except ValueError:
                    return False
            
            try:
                min_stat_msg = await self.bot.wait_for("message", check=min_stat_check, timeout=30)
            except asyncio.TimeoutError:
                return await ctx.send(_("Buy order creation timed out."))
            
            min_stat = int(min_stat_msg.content)
            
            # Ask for maximum stat
            await ctx.send(_("What is the maximum stat you want for this weapon? ({min_stat}-{max_stat})").format(min_stat=min_stat, max_stat=max_possible_stat))
            
            def max_stat_check(m):
                if not m.author == ctx.author or not m.channel == ctx.channel:
                    return False
                try:
                    stat = int(m.content)
                    return min_stat <= stat <= max_possible_stat
                except ValueError:
                    return False
            
            try:
                max_stat_msg = await self.bot.wait_for("message", check=max_stat_check, timeout=30)
            except asyncio.TimeoutError:
                return await ctx.send(_("Buy order creation timed out."))
            
            max_stat = int(max_stat_msg.content)
            
            # Ask for price
            await ctx.send(_("How much gold are you willing to pay per weapon? (1-100,000,000)"))
            
            def price_check(m):
                if not m.author == ctx.author or not m.channel == ctx.channel:
                    return False
                try:
                    price = int(m.content)
                    return 1 <= price <= 100_000_000
                except ValueError:
                    return False
            
            try:
                price_msg = await self.bot.wait_for("message", check=price_check, timeout=30)
            except asyncio.TimeoutError:
                return await ctx.send(_("Buy order creation timed out."))
            
            price = int(price_msg.content)
            
            # Ask for quantity
            await ctx.send(_("How many weapons do you want to buy? (1-100)"))
            
            def quantity_check(m):
                if not m.author == ctx.author or not m.channel == ctx.channel:
                    return False
                try:
                    quantity = int(m.content)
                    return 1 <= quantity <= 100
                except ValueError:
                    return False
            
            try:
                quantity_msg = await self.bot.wait_for("message", check=quantity_check, timeout=30)
            except asyncio.TimeoutError:
                return await ctx.send(_("Buy order creation timed out."))
            
            quantity = int(quantity_msg.content)
            
            # Calculate total cost
            total_cost = price * quantity
            
            # Check if user has enough money
            if ctx.character_data["money"] < total_cost:
                return await ctx.send(_("You don't have enough money to create this buy order."))
            
            # Confirm order
            conf_msg = _(
                "Please confirm your buy order:\n"
                "Weapon Type: **{weapon_type}**\n"
                "Stat Range: **{min_stat}-{max_stat}**\n"
                "Price per Weapon: **${price}**\n"
                "Quantity: **{quantity}**\n"
                "Total Cost: **${total_cost}**\n\n"
                "Type `confirm` to create this buy order."
            ).format(
                weapon_type=weapon_type.title(),
                min_stat=min_stat,
                max_stat=max_stat,
                price=price,
                quantity=quantity,
                total_cost=total_cost
            )
            
            await ctx.send(conf_msg)
            
            def confirm_check(m):
                return m.author == ctx.author and m.channel == ctx.channel and m.content.lower() == "confirm"
            
            try:
                await self.bot.wait_for("message", check=confirm_check, timeout=30)
            except asyncio.TimeoutError:
                return await ctx.send(_("Buy order creation canceled."))
            
            # Create order in DB
            async with self.bot.pool.acquire() as conn:
                # Deduct money
                await conn.execute(
                    'UPDATE profile SET "money"="money"-$1 WHERE "user"=$2;',
                    total_cost,
                    ctx.author.id,
                )
                
                # Create order
                order_id = await conn.fetchval(
                    """
                    INSERT INTO weapon_buy_orders (user_id, weapon_type, min_stat, max_stat, price, quantity)
                    VALUES ($1, $2, $3, $4, $5, $6)
                    RETURNING id;
                    """,
                    ctx.author.id,
                    weapon_type,
                    min_stat,
                    max_stat,
                    price,
                    quantity,
                )
                
                await self.bot.log_transaction(
                    ctx,
                    from_=ctx.author.id,
                    to=2,
                    subject="buy order create",
                    data={"Gold": total_cost, "Weapon Type": weapon_type, "Min Stat": min_stat, "Max Stat": max_stat, "Price": price, "Quantity": quantity},
                    conn=conn,
                )
            
            await ctx.send(_("Buy order #{id} created successfully! Total cost of ${cost} has been deducted from your account.").format(id=order_id, cost=total_cost))

        # Handle crate order
        else:
            # Ask for crate type
            crate_types = ["common", "uncommon", "rare", "magic", "legendary", "divine"]
            crate_str = ", ".join(f"`{c}`" for c in crate_types)
            
            await ctx.send(_("What type of crate are you looking for? Choose from: {types}").format(types=crate_str))
            
            def crate_check(m):
                return m.author == ctx.author and m.channel == ctx.channel and m.content.lower() in crate_types
            
            try:
                crate_msg = await self.bot.wait_for("message", check=crate_check, timeout=30)
            except asyncio.TimeoutError:
                return await ctx.send(_("Buy order creation timed out."))
            
            crate_type = crate_msg.content.lower()
            
            # Ask for price per crate
            await ctx.send(_("How much gold are you willing to pay per crate? (1-100,000,000)"))
            
            def price_check(m):
                if not m.author == ctx.author or not m.channel == ctx.channel:
                    return False
                try:
                    price = int(m.content)
                    return 1 <= price <= 100_000_000
                except ValueError:
                    return False
            
            try:
                price_msg = await self.bot.wait_for("message", check=price_check, timeout=30)
            except asyncio.TimeoutError:
                return await ctx.send(_("Buy order creation timed out."))
            
            price_each = int(price_msg.content)
            
            # Ask for quantity
            await ctx.send(_("How many crates do you want to buy? (1-1000)"))
            
            def quantity_check(m):
                if not m.author == ctx.author or not m.channel == ctx.channel:
                    return False
                try:
                    quantity = int(m.content)
                    return 1 <= quantity <= 1000
                except ValueError:
                    return False
            
            try:
                quantity_msg = await self.bot.wait_for("message", check=quantity_check, timeout=30)
            except asyncio.TimeoutError:
                return await ctx.send(_("Buy order creation timed out."))
            
            quantity = int(quantity_msg.content)
            
            # Calculate total cost
            total_cost = price_each * quantity
            
            # Check if user has enough money
            if ctx.character_data["money"] < total_cost:
                return await ctx.send(_("You don't have enough money to create this buy order."))
            
            # Get crate emoji
            crate_emoji = await self.get_crate_emoji(crate_type)
            
            # Confirm order
            conf_msg = _(
                "Please confirm your buy order:\n"
                "Crate Type: **{crate_emoji} {crate_type}**\n"
                "Price per Crate: **${price_each}**\n"
                "Quantity: **{quantity}**\n"
                "Total Cost: **${total_cost}**\n\n"
                "Type `confirm` to create this buy order."
            ).format(
                crate_emoji=crate_emoji,
                crate_type=crate_type.title(),
                price_each=price_each,
                quantity=quantity,
                total_cost=total_cost
            )
            
            await ctx.send(conf_msg)
            
            def confirm_check(m):
                return m.author == ctx.author and m.channel == ctx.channel and m.content.lower() == "confirm"
            
            try:
                await self.bot.wait_for("message", check=confirm_check, timeout=30)
            except asyncio.TimeoutError:
                return await ctx.send(_("Buy order creation canceled."))
            
            # Create order in DB
            async with self.bot.pool.acquire() as conn:
                # Deduct money
                await conn.execute(
                    'UPDATE profile SET "money"="money"-$1 WHERE "user"=$2;',
                    total_cost,
                    ctx.author.id,
                )
                
                # Create order
                order_id = await conn.fetchval(
                    """
                    INSERT INTO crate_buy_orders (user_id, crate_type, price_each, quantity)
                    VALUES ($1, $2, $3, $4)
                    RETURNING id;
                    """,
                    ctx.author.id,
                    crate_type,
                    price_each,
                    quantity,
                )
                
                await self.bot.log_transaction(
                    ctx,
                    from_=ctx.author.id,
                    to=2,
                    subject="buy order create",
                    data={"Gold": total_cost, "Crate Type": crate_type, "Price Each": price_each, "Quantity": quantity},
                    conn=conn,
                )
            
            await ctx.send(_("Buy order #{id} created successfully! Total cost of ${cost} has been deducted from your account.").format(id=order_id, cost=total_cost))

    @has_char()
    @buyorder.command(name="view", brief=_("View your active buy orders"))
    @locale_doc
    async def buyorder_view(self, ctx):
        _("""View all your active buy orders, both for weapons and crates.""")
        try:
            async with self.bot.pool.acquire() as conn:
                # Get weapon orders
                weapon_orders = await conn.fetch(
                    """
                    SELECT * FROM weapon_buy_orders 
                    WHERE user_id = $1 AND active = TRUE
                    ORDER BY created_at DESC;
                    """,
                    ctx.author.id
                )
                
                # Get crate orders
                crate_orders = await conn.fetch(
                    """
                    SELECT * FROM crate_buy_orders
                    WHERE user_id = $1 AND active = TRUE
                    ORDER BY created_at DESC;
                    """,
                    ctx.author.id
                )
            
            if not weapon_orders and not crate_orders:
                return await ctx.send(_("You don't have any active buy orders."))
            
            # Create embed
            embed = discord.Embed(
                title=_("Your Active Buy Orders"),
                color=discord.Color.gold(),
                description=_("Here are all your active buy orders.")
            )
            
            # Add weapon orders
            if weapon_orders:
                weapon_entries = []
                for order in weapon_orders:
                    remaining = order['quantity'] - order['quantity_filled']
                    total_cost = order['price'] * remaining
                    
                    entry = _(
                        "**Order #{id}** â€¢ {weapon_type}\n"
                        "Stats: {min_stat}-{max_stat} â€¢ Price: ${price} each\n"
                        "Filled: {filled}/{total} â€¢ Remaining: ${total_cost}"
                    ).format(
                        id=order['id'],
                        weapon_type=order['weapon_type'].title(),
                        min_stat=order['min_stat'],
                        max_stat=order['max_stat'],
                        price=order['price'],
                        filled=order['quantity_filled'],
                        total=order['quantity'],
                        total_cost=total_cost
                    )
                    weapon_entries.append(entry)
                
                embed.add_field(
                    name=_("Weapon Buy Orders"),
                    value="\n\n".join(weapon_entries) or _("No weapon buy orders"),
                    inline=False
                )
            
            # Add crate orders
            if crate_orders:
                crate_entries = []
                for order in crate_orders:
                    remaining = order['quantity'] - order['quantity_filled']
                    total_cost = order['price_each'] * remaining
                    crate_emoji = await self.get_crate_emoji(order['crate_type'])
                    
                    entry = _(
                        "**Order #{id}** â€¢ {emoji} {crate_type}\n"
                        "Price: ${price} each\n"
                        "Filled: {filled}/{total} â€¢ Remaining: ${total_cost}"
                    ).format(
                        id=order['id'],
                        emoji=crate_emoji,
                        crate_type=order['crate_type'].title(),
                        price=order['price_each'],
                        filled=order['quantity_filled'],
                        total=order['quantity'],
                        total_cost=total_cost
                    )
                    crate_entries.append(entry)
                
                embed.add_field(
                    name=_("Crate Buy Orders"),
                    value="\n\n".join(crate_entries) or _("No crate buy orders"),
                    inline=False
                )
            
            embed.set_footer(text=_("Use {prefix}buyorder cancel <id> to cancel an order").format(prefix=ctx.clean_prefix))
            
            await ctx.send(embed=embed)
        except Exception as e:
            await ctx.send(e)

    @has_char()
    @buyorder.command(name="cancel", brief=_("Cancel one of your buy orders"))
    @locale_doc
    async def buyorder_cancel(self, ctx, order_id: int):
        _("""Cancel one of your active buy orders and get a refund for unfulfilled quantity.""")
        
        async with self.bot.pool.acquire() as conn:
            # Check if it's a weapon order
            weapon_order = await conn.fetchrow(
                """
                SELECT * FROM weapon_buy_orders 
                WHERE id = $1 AND user_id = $2 AND active = TRUE;
                """,
                order_id,
                ctx.author.id
            )
            
            if weapon_order:
                remaining = weapon_order['quantity'] - weapon_order['quantity_filled']
                refund_amount = remaining * weapon_order['price']
                
                # Mark as inactive
                await conn.execute(
                    """
                    UPDATE weapon_buy_orders 
                    SET active = FALSE 
                    WHERE id = $1;
                    """,
                    order_id
                )
                
                # Refund money
                await conn.execute(
                    'UPDATE profile SET "money"="money"+$1 WHERE "user"=$2;',
                    refund_amount,
                    ctx.author.id,
                )
                
                await self.bot.log_transaction(
                    ctx,
                    from_=2,
                    to=ctx.author.id,
                    subject="buy order cancel refund",
                    data={"Gold": refund_amount, "Order ID": order_id, "Type": "weapon"},
                    conn=conn,
                )
                
                return await ctx.send(
                    _("Order #{id} has been canceled. ${refund} has been refunded for {remaining} unfulfilled items.").format(
                        id=order_id,
                        refund=refund_amount,
                        remaining=remaining
                    )
                )
            
            # Check if it's a crate order
            crate_order = await conn.fetchrow(
                """
                SELECT * FROM crate_buy_orders 
                WHERE id = $1 AND user_id = $2 AND active = TRUE;
                """,
                order_id,
                ctx.author.id
            )
            
            if crate_order:
                remaining = crate_order['quantity'] - crate_order['quantity_filled']
                refund_amount = remaining * crate_order['price_each']
                
                # Mark as inactive
                await conn.execute(
                    """
                    UPDATE crate_buy_orders 
                    SET active = FALSE 
                    WHERE id = $1;
                    """,
                    order_id
                )
                
                # Refund money
                await conn.execute(
                    'UPDATE profile SET "money"="money"+$1 WHERE "user"=$2;',
                    refund_amount,
                    ctx.author.id,
                )
                
                await self.bot.log_transaction(
                    ctx,
                    from_=2,
                    to=ctx.author.id,
                    subject="buy order cancel refund",
                    data={"Gold": refund_amount, "Order ID": order_id, "Type": "crate"},
                    conn=conn,
                )
                
                return await ctx.send(
                    _("Order #{id} has been canceled. ${refund} has been refunded for {remaining} unfulfilled crates.").format(
                        id=order_id,
                        refund=refund_amount,
                        remaining=remaining
                    )
                )
            
            await ctx.send(_("You don't have an active buy order with ID {id}, or it doesn't belong to you.").format(id=order_id))
    
    @has_char()
    @buyorder.command(name="list", brief=_("List all active buy orders"))
    @locale_doc
    async def buyorder_list(self, ctx):
        _("""List all active buy orders from all players. You can use this to find orders to fulfill.""")
        
        async with self.bot.pool.acquire() as conn:
            # Get active weapon orders
            weapon_orders = await conn.fetch(
                """
                SELECT 
                    w.id, 
                    w.user_id, 
                    w.weapon_type, 
                    w.min_stat, 
                    w.max_stat, 
                    w.price, 
                    w.quantity, 
                    w.quantity_filled, 
                    p."user" 
                FROM 
                    weapon_buy_orders w 
                JOIN 
                    profile p ON w.user_id = p."user" 
                WHERE 
                    w.active = TRUE 
                ORDER BY 
                    w.created_at DESC 
                LIMIT 15;
                """
            )
            
            # Get active crate orders
            crate_orders = await conn.fetch(
                """
                SELECT 
                    c.id, 
                    c.user_id, 
                    c.crate_type, 
                    c.price_each, 
                    c.quantity, 
                    c.quantity_filled, 
                    p."user" 
                FROM 
                    crate_buy_orders c 
                JOIN 
                    profile p ON c.user_id = p."user" 
                WHERE 
                    c.active = TRUE 
                ORDER BY 
                    c.created_at DESC 
                LIMIT 15;
                """
            )
        
        if not weapon_orders and not crate_orders:
            return await ctx.send(_("There are no active buy orders available."))
        
        # Create pages for pagination
        pages = []
        
        if weapon_orders:
            # Create weapon orders page
            weapon_embed = discord.Embed(
                title=_("Active Weapon Buy Orders"),
                color=discord.Color.blue(),
                description=_("Here are the active weapon buy orders. Use {prefix}buyorder fulfill <id> to fulfill an order.").format(prefix=ctx.clean_prefix)
            )
            
            for order in weapon_orders:
                user = self.bot.get_user(order["user"])
                username = user.name if user else _("Unknown User")
                
                remaining = order['quantity'] - order['quantity_filled']
                value = _(
                    "**Order #{id}** by {username} ({user_id})\n"
                    "Type: {weapon_type} | Stats: {min_stat}-{max_stat}\n"
                    "Price: ${price} each | Remaining: {remaining}/{total}"
                ).format(
                    id=order["id"],
                    username=username,
                    user_id=order["user_id"],
                    weapon_type=order["weapon_type"].title(),
                    min_stat=order["min_stat"],
                    max_stat=order["max_stat"],
                    price=order["price"],
                    remaining=remaining,
                    total=order["quantity"]
                )
                
                weapon_embed.add_field(name=f"Weapon Order #{order['id']}", value=value, inline=False)
            
            pages.append(weapon_embed)
        
        if crate_orders:
            # Create crate orders page
            crate_embed = discord.Embed(
                title=_("Active Crate Buy Orders"),
                color=discord.Color.green(),
                description=_("Here are the active crate buy orders. Use {prefix}buyorder fulfill <id> to fulfill an order.").format(prefix=ctx.clean_prefix)
            )
            
            for order in crate_orders:
                user = self.bot.get_user(order["user"])
                username = user.name if user else _("Unknown User")
                crate_emoji = await self.get_crate_emoji(order['crate_type'])
                
                remaining = order['quantity'] - order['quantity_filled']
                value = _(
                    "**Order #{id}** by {username} ({user_id})\n"
                    "Type: {emoji} {crate_type}\n"
                    "Price: ${price} each | Remaining: {remaining}/{total}"
                ).format(
                    id=order["id"],
                    username=username,
                    user_id=order["user_id"],
                    emoji=crate_emoji,
                    crate_type=order["crate_type"].title(),
                    price=order["price_each"],
                    remaining=remaining,
                    total=order["quantity"]
                )
                
                crate_embed.add_field(name=f"Crate Order #{order['id']}", value=value, inline=False)
            
            pages.append(crate_embed)
        
        # Add navigation footers
        if len(pages) > 1:
            pages[0].set_footer(text=_("Page 1/{total} | Use {prefix}buyorder list to see all orders").format(total=len(pages), prefix=ctx.clean_prefix))
            pages[1].set_footer(text=_("Page 2/{total} | Use {prefix}buyorder list to see all orders").format(total=len(pages), prefix=ctx.clean_prefix))
        
        # Send pages
        if len(pages) == 1:
            await ctx.send(embed=pages[0])
        else:
            await self.bot.paginator.Paginator(extras=pages).paginate(ctx)
    
    @has_char()
    @buyorder.command(name="history", brief=_("View your buy order history"))
    @locale_doc
    async def buyorder_history(self, ctx):
        _("""View the history of your fulfilled buy orders, both as buyer and seller.""")
        try:
            async with self.bot.pool.acquire() as conn:
                # Get order history
                history = await conn.fetch(
                    """
                    SELECT * FROM buy_order_fulfillments 
                    WHERE buyer_id = $1 OR seller_id = $1 
                    ORDER BY fulfilled_at DESC 
                    LIMIT 20;
                    """,
                    ctx.author.id
                )
            
            if not history:
                return await ctx.send(_("You don't have any buy order history."))
            
            # Create embed
            embed = discord.Embed(
                title=_("Your Buy Order History"),
                color=discord.Color.gold(),
                description=_("Here is the history of your fulfilled buy orders.")
            )
            
            # Add history entries
            for entry in history:
                is_buyer = entry['buyer_id'] == ctx.author.id
                other_user = self.bot.get_user(entry['seller_id'] if is_buyer else entry['buyer_id'])
                other_username = other_user.name if other_user else _("Unknown User")
                order_type = entry['order_type']
                
                if is_buyer:
                    header = _("You bought from {seller}").format(seller=other_username)
                else:
                    header = _("You sold to {buyer}").format(buyer=other_username)
                
                if order_type == 'weapon':
                    value = _(
                        "Item: {item_name} ({weapon_type})\n"
                        "Stats: {stat}\n"
                        "Price: ${price} | Date: {date}"
                    ).format(
                        item_name=entry['item_name'],
                        weapon_type=entry['item_type'],
                        stat=entry['stat'],
                        price=entry['price'],
                        date=entry['fulfilled_at'].strftime("%Y-%m-%d %H:%M")
                    )
                else:  # Crate order
                    value = _(
                        "Item: {emoji} {item_type} (x{quantity})\n"
                        "Price: ${price} total | Date: {date}"
                    ).format(
                        emoji=await self.get_crate_emoji(entry['item_type']),
                        item_type=entry['item_type'].title(),
                        quantity=entry['quantity'],
                        price=entry['price'] * entry['quantity'],
                        date=entry['fulfilled_at'].strftime("%Y-%m-%d %H:%M")
                    )
                
                embed.add_field(name=header, value=value, inline=False)
            
            await ctx.send(embed=embed)
        except Exception as e:
            await ctx.send(e)
    
    @has_char()
    @buyorder.command(name="fulfill", brief=_("Fulfill a buy order"))
    @locale_doc
    async def buyorder_fulfill(self, ctx, order_id: int):
        _("""Fulfill a buy order by selling your items to the buyer.""")
        try:
            async with self.bot.pool.acquire() as conn:
                # Check if it's a weapon order
                weapon_order = await conn.fetchrow(
                    """
                    SELECT 
                        o.*, 
                        p."money" as buyer_money 
                    FROM 
                        weapon_buy_orders o 
                    JOIN 
                        profile p ON o.user_id = p."user" 
                    WHERE 
                        o.id = $1 AND o.active = TRUE;
                    """,
                    order_id
                )
                
                if weapon_order:
                    # Cannot fulfill own order
                    if weapon_order['user_id'] == ctx.author.id:
                        return await ctx.send(_("You cannot fulfill your own buy order."))
                    
                    # Get user's owned weapons
                    owned_weapons = await conn.fetch(
                        'SELECT * FROM allitems WHERE "owner"=$1 AND "type"=$2;',
                        ctx.author.id,
                        weapon_order['weapon_type']
                    )
                    
                    # Filter weapons that match the buy order criteria
                    matching_weapons = []
                    for weapon in owned_weapons:
                        if weapon_order['min_stat'] <= weapon['damage'] <= weapon_order['max_stat']:
                            matching_weapons.append(weapon)
                    
                    if not matching_weapons:
                        return await ctx.send(
                            _("You don't have any {type} weapons with stats between {min_stat} and {max_stat}.").format(
                                type=weapon_order['weapon_type'],
                                min_stat=weapon_order['min_stat'],
                                max_stat=weapon_order['max_stat']
                            )
                        )
                    
                    # Determine how many can be fulfilled
                    remaining = weapon_order['quantity'] - weapon_order['quantity_filled']
                    can_fulfill = min(len(matching_weapons), remaining)
                    
                    if can_fulfill == 0:
                        return await ctx.send(_("This order has been fully fulfilled already."))
                    
                    # Ask user how many to sell if they have multiple matching weapons
                    if len(matching_weapons) > 1 and can_fulfill > 1:
                        await ctx.send(
                            _("You have {count} matching weapons. How many would you like to sell? (1-{max}, cancel to abort)").format(
                                count=len(matching_weapons),
                                max=can_fulfill
                            )
                        )
                        
                        def check(m):
                            return m.author == ctx.author and m.channel == ctx.channel
                        
                        try:
                            msg = await self.bot.wait_for("message", check=check, timeout=30)
                            if msg.content.lower() == "cancel":
                                return await ctx.send(_("Cancelled."))
                            
                            try:
                                amount = int(msg.content)
                                if amount < 1 or amount > can_fulfill:
                                    return await ctx.send(_("Invalid amount. Aborting."))
                            except ValueError:
                                return await ctx.send(_("Invalid amount. Aborting."))
                            
                        except asyncio.TimeoutError:
                            return await ctx.send(_("You took too long. Aborting."))
                    else:
                        amount = 1
                    
                    # Calculate total price
                    total_price = amount * weapon_order['price']
                    
                    # Note: We don't need to check if buyer has enough money since it was
                    # already deducted when the order was created
                    
                    # Get confirmation
                    weapons_to_sell = matching_weapons[:amount]
                    weapon_names = [w['name'] for w in weapons_to_sell]
                    
                    confirm_text = _(
                        "Are you sure you want to sell {count} weapons for a total of ${price}?\n"
                        "The weapons to be sold are: {weapons}"
                    ).format(
                        count=amount,
                        price=total_price,
                        weapons=", ".join(weapon_names)
                    )
                    
                    if not await ctx.confirm(confirm_text):
                        return await ctx.send(_("Order fulfillment cancelled."))
                    
                    # Process the sale
                    # 1. Update the order
                    await conn.execute(
                        """
                        UPDATE weapon_buy_orders 
                        SET quantity_filled = quantity_filled + $1, 
                            active = CASE WHEN quantity_filled + $1 >= quantity THEN FALSE ELSE TRUE END 
                        WHERE id = $2;
                        """,
                        amount,
                        order_id
                    )
                    
                    # 2. Transfer money
                    await conn.execute(
                        'UPDATE profile SET "money"="money"-$1 WHERE "user"=$2;',
                        total_price,
                        weapon_order['user_id']
                    )
                    
                    await conn.execute(
                        'UPDATE profile SET "money"="money"+$1 WHERE "user"=$2;',
                        total_price,
                        ctx.author.id
                    )
                    
                    # 3. Transfer weapons
                    for weapon in weapons_to_sell:
                        await conn.execute(
                            'UPDATE allitems SET "owner"=$1 WHERE "id"=$2;',
                            weapon_order['user_id'],
                            weapon['id']
                        )
                    
                        # Add to history
                        await conn.execute(
                            """
                            INSERT INTO buy_order_fulfillments 
                            (order_id, order_type, buyer_id, seller_id, item_id, crate_type, crate_quantity, price) 
                            VALUES ($1, $2, $3, $4, $5, $6, $7, $8);
                            """,
                            order_id,
                            'weapon',
                            weapon_order['user_id'],
                            ctx.author.id,
                            weapon['id'],  # item_id 
                            weapon_order['weapon_type'],  # crate_type for weapon type
                            1,  # crate_quantity for single weapon
                            weapon_order['price']
                        )
                    
                    # Log transactions
                    await self.bot.log_transaction(
                        ctx,
                        from_=weapon_order['user_id'],
                        to=ctx.author.id,
                        subject="buy order fulfill payment",
                        data={
                            "Gold": total_price,
                            "Order ID": order_id,
                            "Type": "weapon",
                            "Items": weapon_names
                        },
                        conn=conn,
                    )
                    
                    # 4. Notify users
                    await ctx.send(
                        _("Successfully sold {count} weapons for ${price}. The money has been added to your account.").format(
                            count=amount,
                            price=total_price
                        )
                    )
                    
                    # Check if order is now completely fulfilled
                    is_complete = (weapon_order['quantity_filled'] + amount) >= weapon_order['quantity']
                    
                    buyer = self.bot.get_user(weapon_order['user_id'])
                    if buyer:
                        try:
                            if is_complete:
                                await buyer.send(
                                    _("Your buy order #{id} has been completely fulfilled! {name} sold you {count} {type} weapons for ${price}.").format(
                                        id=order_id,
                                        name=ctx.author.name,
                                        count=amount,
                                        type=weapon_order['weapon_type'],
                                        price=total_price
                                    )
                                )
                            else:
                                await buyer.send(
                                    _("Your buy order #{id} has been partially fulfilled! {name} sold you {count} {type} weapons for ${price}.").format(
                                        id=order_id,
                                        name=ctx.author.name,
                                        count=amount,
                                        type=weapon_order['weapon_type'],
                                        price=total_price
                                    )
                                )
                        except discord.Forbidden:
                            pass
                    
                    return
                
                # Check if it's a crate order
                crate_order = await conn.fetchrow(
                    """
                    SELECT 
                        o.*, 
                        p."money" as buyer_money 
                    FROM 
                        crate_buy_orders o 
                    JOIN 
                        profile p ON o.user_id = p."user" 
                    WHERE 
                        o.id = $1 AND o.active = TRUE;
                    """,
                    order_id
                )
                
                if crate_order:
                    # Cannot fulfill own order
                    if crate_order['user_id'] == ctx.author.id:
                        return await ctx.send(_("You cannot fulfill your own buy order."))
                    
                    # Check if user has crates
                    crate_column = f'crates_{crate_order["crate_type"].lower()}'
                    user_crates = await conn.fetchval(
                        f'SELECT "{crate_column}" FROM profile WHERE "user"=$1;',
                        ctx.author.id
                    )
                    
                    if not user_crates:
                        return await ctx.send(
                            _("You don't have any {crate_type} crates.").format(
                                crate_type=crate_order['crate_type']
                            )
                        )
                    
                    # Determine how many can be fulfilled
                    remaining = crate_order['quantity'] - crate_order['quantity_filled']
                    can_fulfill = min(user_crates, remaining)
                    
                    if can_fulfill == 0:
                        return await ctx.send(_("This order has been fully fulfilled already."))
                    
                    # Ask user how many to sell if they have multiple crates
                    if user_crates > 1 and can_fulfill > 1:
                        await ctx.send(
                            _("You have {count} {crate_type} crates. How many would you like to sell? (1-{max}, cancel to abort)").format(
                                count=user_crates,
                                crate_type=crate_order['crate_type'],
                                max=can_fulfill
                            )
                        )
                        
                        def check(m):
                            return m.author == ctx.author and m.channel == ctx.channel
                        
                        try:
                            msg = await self.bot.wait_for("message", check=check, timeout=30)
                            if msg.content.lower() == "cancel":
                                return await ctx.send(_("Cancelled."))
                            
                            try:
                                amount = int(msg.content)
                                if amount < 1 or amount > can_fulfill:
                                    return await ctx.send(_("Invalid amount. Aborting."))
                            except ValueError:
                                return await ctx.send(_("Invalid amount. Aborting."))
                            
                        except asyncio.TimeoutError:
                            return await ctx.send(_("You took too long. Aborting."))
                    else:
                        amount = 1
                    
                    # Calculate total price
                    total_price = amount * crate_order['price_each']
                    
                    # Note: We don't need to check if buyer has enough money since it was
                    # already deducted when the order was created
                    
                    # Get confirmation
                    crate_emoji = await self.get_crate_emoji(crate_order['crate_type'])
                    
                    confirm_text = _(
                        "Are you sure you want to sell {count} {emoji} {crate_type} crates for a total of ${price}?"
                    ).format(
                        count=amount,
                        emoji=crate_emoji,
                        crate_type=crate_order['crate_type'],
                        price=total_price
                    )
                    
                    if not await ctx.confirm(confirm_text):
                        return await ctx.send(_("Order fulfillment cancelled."))
                    
                    # Process the sale
                    # 1. Update the order
                    await conn.execute(
                        """
                        UPDATE crate_buy_orders 
                        SET quantity_filled = quantity_filled + $1, 
                            active = CASE WHEN quantity_filled + $1 >= quantity THEN FALSE ELSE TRUE END 
                        WHERE id = $2;
                        """,
                        amount,
                        order_id
                    )
                    
                    # 2. Transfer money
                    await conn.execute(
                        'UPDATE profile SET "money"="money"-$1 WHERE "user"=$2;',
                        total_price,
                        crate_order['user_id']
                    )
                    
                    await conn.execute(
                        'UPDATE profile SET "money"="money"+$1 WHERE "user"=$2;',
                        total_price,
                        ctx.author.id
                    )
                    
                    # 3. Transfer crates
                    crate_column = f'crates_{crate_order["crate_type"].lower()}'
                    
                    await conn.execute(
                        f'UPDATE profile SET "{crate_column}"="{crate_column}"-$1 WHERE "user"=$2;',
                        amount,
                        ctx.author.id
                    )
                    
                    await conn.execute(
                        f'UPDATE profile SET "{crate_column}"="{crate_column}"+$1 WHERE "user"=$2;',
                        amount,
                        crate_order['user_id']
                    )
                    
                    # Add to history
                    await conn.execute(
                        """
                        INSERT INTO buy_order_fulfillments 
                        (order_id, order_type, buyer_id, seller_id, item_id, crate_type, crate_quantity, price) 
                        VALUES ($1, $2, $3, $4, NULL, $5, $6, $7);
                        """,
                        order_id,
                        'crate',
                        crate_order['user_id'],
                        ctx.author.id,
                        crate_order['crate_type'],
                        amount,
                        crate_order['price_each']
                    )
                    
                    # Log transactions
                    await self.bot.log_transaction(
                        ctx,
                        from_=crate_order['user_id'],
                        to=ctx.author.id,
                        subject="buy order fulfill payment",
                        data={
                            "Gold": total_price,
                            "Order ID": order_id,
                            "Type": "crate",
                            "Crate Type": crate_order['crate_type'],
                            "Amount": amount
                        },
                        conn=conn,
                    )
                    
                    # 4. Notify users
                    await ctx.send(
                        _("Successfully sold {count} {crate_type} crates for ${price}. The money has been added to your account.").format(
                            count=amount,
                            crate_type=crate_order['crate_type'],
                            price=total_price
                        )
                    )
                    
                    # Check if order is now completely fulfilled
                    is_complete = (crate_order['quantity_filled'] + amount) >= crate_order['quantity']
                    
                    buyer = self.bot.get_user(crate_order['user_id'])
                    if buyer:
                        try:
                            if is_complete:
                                await buyer.send(
                                    _("Your buy order #{id} has been completely fulfilled! {name} sold you {count} {crate_type} crates for ${price}.").format(
                                        id=order_id,
                                        name=ctx.author.name,
                                        count=amount,
                                        crate_type=crate_order['crate_type'],
                                        price=total_price
                                    )
                                )
                            else:
                                await buyer.send(
                                    _("Your buy order #{id} has been partially fulfilled! {name} sold you {count} {crate_type} crates for ${price}.").format(
                                        id=order_id,
                                        name=ctx.author.name,
                                        count=amount,
                                        crate_type=crate_order['crate_type'],
                                        price=total_price
                                    )
                                )
                        except discord.Forbidden:
                            pass
                    
                    return
                
                await ctx.send(_("No active buy order found with ID {id}.").format(id=order_id))
        except Exception as e:
            await ctx.send(e)
    # Helper method to get crate emoji
    async def get_crate_emoji(self, crate_type):
        crate_type = crate_type.lower()
        try:
            # Access emotes as attributes since it's a namedtuple
            return getattr(self.bot.cogs["Crates"].emotes, crate_type)
        except (AttributeError, KeyError):
            return "ðŸ“¦"


    @has_char()
    @buyorder.command(name="search", brief=_("Search for buy orders"))
    @locale_doc
    async def buyorder_search(self, ctx, *, query: str = ""):
        _("""Search for buy orders with flexible parameters.
        
        **Search options:**
        `type:weapon` or `type:crate` - Filter by item type
        `weapon:sword` - Search for specific weapon type
        `crate:common` - Search for specific crate type
        `stats:30-50` - Search for weapons with stats in a range
        `price:<1000` - Search for orders with price less than 1000
        `price:>1000` - Search for orders with price more than 1000
        `price:1000-5000` - Search for orders with price between 1000 and 5000
        `sort:price` - Sort by price (ascending)
        `sort:price_desc` - Sort by price (descending)
        `sort:newest` - Sort by creation date (newest first)
        `sort:oldest` - Sort by creation date (oldest first)
        
        You can combine multiple search parameters. For example:  
        `{prefix}buyorder search type:weapon weapon:sword stats:30-50 price:<5000 sort:price`
        
        If no parameters are provided, all active buy orders will be displayed.
        """)
        try:
            # Parse search parameters
            params = {}
            sort_by = "created_at DESC"
            order_type = None
            
            if query:
                for param in query.split():
                    if ':' not in param:
                        continue
                    
                    key, value = param.split(':', 1)
                    key = key.lower()
                    value = value.lower()
                    
                    if key == 'type':
                        if value in ['weapon', 'weapons', 'w']:
                            order_type = 'weapon'
                        elif value in ['crate', 'crates', 'c']:
                            order_type = 'crate'
                    elif key == 'weapon':
                        params['weapon_type'] = value
                    elif key == 'crate':
                        params['crate_type'] = value
                    elif key == 'stats':
                        if '-' in value:
                            min_stat, max_stat = value.split('-', 1)
                            try:
                                params['min_stat'] = int(min_stat)
                                params['max_stat'] = int(max_stat)
                            except ValueError:
                                return await ctx.send(_("Stats must be numbers, e.g. stats:30-50"))
                        else:
                            try:
                                stat = int(value)
                                params['min_stat'] = stat
                                params['max_stat'] = stat
                            except ValueError:
                                return await ctx.send(_("Stats must be numbers, e.g. stats:30-50"))
                    elif key == 'price':
                        if value.startswith('<'):
                            try:
                                params['max_price'] = int(value[1:])
                            except ValueError:
                                return await ctx.send(_("Price must be a number, e.g. price:<5000"))
                        elif value.startswith('>'):
                            try:
                                params['min_price'] = int(value[1:])
                            except ValueError:
                                return await ctx.send(_("Price must be a number, e.g. price:>1000"))
                        elif '-' in value:
                            min_price, max_price = value.split('-', 1)
                            try:
                                params['min_price'] = int(min_price)
                                params['max_price'] = int(max_price)
                            except ValueError:
                                return await ctx.send(_("Price must be a number, e.g. price:1000-5000"))
                        else:
                            try:
                                price = int(value)
                                params['min_price'] = price
                                params['max_price'] = price
                            except ValueError:
                                return await ctx.send(_("Price must be a number, e.g. price:5000"))
                    elif key == 'sort':
                        if value in ['price', 'p']:
                            sort_by = "price ASC"
                            if order_type == 'crate':
                                sort_by = "price_each ASC"
                        elif value in ['price_desc', 'pd']:
                            sort_by = "price DESC"
                            if order_type == 'crate':
                                sort_by = "price_each DESC"
                        elif value in ['newest', 'new', 'n']:
                            sort_by = "created_at DESC"
                        elif value in ['oldest', 'old', 'o']:
                            sort_by = "created_at ASC"
            
            # Build queries based on the parameters
            weapon_conditions = ["active = TRUE"]
            crate_conditions = ["active = TRUE"]
            weapon_params = []
            crate_params = []
            param_index = 1
            
            # Add conditions based on parsed parameters
            if 'weapon_type' in params:
                weapon_conditions.append(f"weapon_type ILIKE ${param_index}")
                weapon_params.append(f"%{params['weapon_type']}%")
                param_index += 1
            
            if 'crate_type' in params:
                crate_conditions.append(f"crate_type ILIKE ${param_index}")
                crate_params.append(f"%{params['crate_type']}%")
                param_index += 1
            
            if 'min_stat' in params:
                weapon_conditions.append(f"min_stat >= ${param_index}")
                weapon_params.append(params['min_stat'])
                param_index += 1
            
            if 'max_stat' in params:
                weapon_conditions.append(f"max_stat <= ${param_index}")
                weapon_params.append(params['max_stat'])
                param_index += 1
            
            if 'min_price' in params:
                weapon_conditions.append(f"price >= ${param_index}")
                weapon_params.append(params['min_price'])
                crate_conditions.append(f"price_each >= ${param_index}")
                crate_params.append(params['min_price'])
                param_index += 1
            
            if 'max_price' in params:
                weapon_conditions.append(f"price <= ${param_index}")
                weapon_params.append(params['max_price'])
                crate_conditions.append(f"price_each <= ${param_index}")
                crate_params.append(params['max_price'])
                param_index += 1
            
            # Create SQL queries
            weapon_query = f"""
            SELECT 
                w.id, 
                w.user_id, 
                w.weapon_type, 
                w.min_stat, 
                w.max_stat, 
                w.price, 
                w.quantity, 
                w.quantity_filled, 
                w.created_at,
                p."user" 
            FROM 
                weapon_buy_orders w 
            JOIN 
                profile p ON w.user_id = p."user" 
            WHERE 
                {' AND '.join(weapon_conditions)} 
            ORDER BY 
                {sort_by} 
            LIMIT 30;
            """
            
            crate_query = f"""
            SELECT 
                c.id, 
                c.user_id, 
                c.crate_type, 
                c.price_each, 
                c.quantity, 
                c.quantity_filled, 
                c.created_at,
                p."user" 
            FROM 
                crate_buy_orders c 
            JOIN 
                profile p ON c.user_id = p."user" 
            WHERE 
                {' AND '.join(crate_conditions)} 
            ORDER BY 
                {sort_by} 
            LIMIT 30;
            """
            
            # Execute queries
            async with self.bot.pool.acquire() as conn:
                weapon_orders = []
                crate_orders = []
                
                if order_type != 'crate':
                    weapon_orders = await conn.fetch(weapon_query, *weapon_params)
                
                if order_type != 'weapon':
                    crate_orders = await conn.fetch(crate_query, *crate_params)
            
            # Initialize pages
            pages = []
            total_results = len(weapon_orders) + len(crate_orders)
            
            if total_results == 0:
                return await ctx.send(_("No buy orders found matching your search criteria."))
            
            # Format search summary
            search_summary = []
            if 'weapon_type' in params:
                search_summary.append(_("Weapon type: {type}").format(type=params['weapon_type']))
            if 'crate_type' in params:
                search_summary.append(_("Crate type: {type}").format(type=params['crate_type']))
            if 'min_stat' in params and 'max_stat' in params:
                search_summary.append(_("Stats: {min}-{max}").format(min=params['min_stat'], max=params['max_stat']))
            if 'min_price' in params and 'max_price' in params:
                search_summary.append(_("Price: ${min}-${max}").format(min=params['min_price'], max=params['max_price']))
            elif 'min_price' in params:
                search_summary.append(_("Price: >=${min}").format(min=params['min_price']))
            elif 'max_price' in params:
                search_summary.append(_("Price: <=${max}").format(max=params['max_price']))
            
            search_criteria = "\n".join(search_summary) if search_summary else _("All active orders")
            
            # Initialize chunks for pagination
            weapon_chunks = []
            crate_chunks = []
            
            # Group orders by type for display
            if weapon_orders:
                weapon_chunks = [weapon_orders[i:i+10] for i in range(0, len(weapon_orders), 10)]
                for i, chunk in enumerate(weapon_chunks):
                    embed = discord.Embed(
                        title=_("Weapon Buy Orders"),
                        color=discord.Color.blue(),
                        description=_("Search results: {total} orders found\n\n{criteria}").format(
                            total=total_results,
                            criteria=search_criteria
                        )
                    )
                    
                    for order in chunk:
                        remaining = order['quantity'] - order['quantity_filled']
                        
                        user = self.bot.get_user(order["user_id"])
                        username = user.name if user else _("Unknown User")
                        
                        value = _(
                            "**Posted by:** {username} ({user_id})\n"
                            "**Type:** {weapon_type} | **Stats:** {min_stat}-{max_stat}\n"
                            "**Price:** ${price} each | **Remaining:** {remaining}/{total}\n"
                            "**Posted:** {time_ago}"
                        ).format(
                            username=username,
                            user_id=order["user_id"],
                            weapon_type=order["weapon_type"].title(),
                            min_stat=order["min_stat"],
                            max_stat=order["max_stat"],
                            price=order["price"],
                            remaining=remaining,
                            total=order["quantity"],
                            time_ago=self.format_time_ago(order["created_at"])
                        )
                        
                        embed.add_field(
                            name=_("Weapon Order #{id}").format(id=order['id']),
                            value=value,
                            inline=False
                        )
                    
                    embed.set_footer(text=_("Page {page}/{total} | Use {prefix}buyorder fulfill <id> to fulfill an order").format(
                        page=i+1,
                        total=len(weapon_chunks) + len(crate_chunks),
                        prefix=ctx.clean_prefix
                    ))
                    
                    pages.append(embed)
            
            if crate_orders:
                crate_chunks = [crate_orders[i:i+10] for i in range(0, len(crate_orders), 10)]
                for i, chunk in enumerate(crate_chunks):
                    embed = discord.Embed(
                        title=_("Crate Buy Orders"),
                        color=discord.Color.green(),
                        description=_("Search results: {total} orders found\n\n{criteria}").format(
                            total=total_results,
                            criteria=search_criteria
                        )
                    )
                    
                    for order in chunk:
                        remaining = order['quantity'] - order['quantity_filled']
                        
                        user = self.bot.get_user(order["user_id"])
                        username = user.name if user else _("Unknown User")
                        crate_emoji = await self.get_crate_emoji(order['crate_type'])
                        
                        value = _(
                            "**Posted by:** {username} ({user_id})\n"
                            "**Type:** {emoji} {crate_type}\n"
                            "**Price:** ${price} each | **Remaining:** {remaining}/{total}\n"
                            "**Posted:** {time_ago}"
                        ).format(
                            username=username,
                            user_id=order["user_id"],
                            emoji=crate_emoji,
                            crate_type=order["crate_type"].title(),
                            price=order["price_each"],
                            remaining=remaining,
                            total=order["quantity"],
                            time_ago=self.format_time_ago(order["created_at"])
                        )
                        
                        embed.add_field(
                            name=_("Crate Order #{id}").format(id=order['id']),
                            value=value,
                            inline=False
                        )
                    
                    embed.set_footer(text=_("Page {page}/{total} | Use {prefix}buyorder fulfill <id> to fulfill an order").format(
                        page=len(weapon_chunks) + i+1,
                        total=len(weapon_chunks) + len(crate_chunks),
                        prefix=ctx.clean_prefix
                    ))
                    
                    pages.append(embed)
            
            # Send results with pagination
            if len(pages) == 1:
                await ctx.send(embed=pages[0])
            else:
                await self.bot.paginator.Paginator(extras=pages).paginate(ctx)
        
        except Exception as e:
            await ctx.send(f"An error occurred: {e}")
    
    def format_time_ago(self, timestamp):
        """Format a timestamp into a human-readable 'time ago' string."""
        # Make sure timestamp has timezone info if it doesn't already
        if timestamp.tzinfo is None:
            timestamp = timestamp.replace(tzinfo=datetime.timezone.utc)
            
        now = datetime.datetime.now(datetime.timezone.utc)
        delta = now - timestamp
        
        if delta.days > 0:
            if delta.days == 1:
                return "1 day ago"
            return f"{delta.days} days ago"
        
        hours, remainder = divmod(delta.seconds, 3600)
        if hours > 0:
            if hours == 1:
                return "1 hour ago"
            return f"{hours} hours ago"
        
        minutes, seconds = divmod(remainder, 60)
        if minutes > 0:
            if minutes == 1:
                return "1 minute ago"
            return f"{minutes} minutes ago"
        
        return "Just now"


async def setup(bot):
    await bot.add_cog(BuyOrders(bot))
